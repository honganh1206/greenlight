# User Activation

What we will do:

1. When there is a new user registration, create a secured random activation token
2. Hash this token in a new `token` table
3. Send this token (unhashed version) to the welcome email
4. Users submit the token to the `PUT /v1/users/activated` endpoint
5. Update the `activated` status in the `users` table to true
6. Remove the activation token

Notes on the `tokens` table:

- The `hash` column will store a SHA-256 **hash** of the activation token, not the token itself
- The `user_id` column will have a foreign key constraint to the `users` table.
- We also use `ON DELETE CASCADE` to tell PostgreSQL to _automatically delete all records for a user_ in the `tokens` table if the parent record gets deleted
- We only set a **short** expiry time for values in the `expiry` column, but long enough for the users to use it
- The `scope` column denotes the **purpose** of the token. This will be later used for **authorization tokens**

## Activation token

The token should be generated by a _cryptographiically secure random number generator_ (CSPRNG) and has enough _randomness_ that is impossible to guess

## Sending activation tokens

Two reasons why we instruct users to activate by issuing a `PUT` request instead of clicking on a link:

1. We do not use `GET` since it should only be used to fetch resources
2. The user's web browser or antivirus will pre-fetch the link URL in the background, inadvertently activating the account

We also need a `createActivationTokenHandler` for re-sending activation tokens

## Activating a user

The relationship between the `users` and `tokens` tables is a **one-to-many relationship**: One user can have many tokens, but a token only belongs to one user

How to activate a user:

1. The user submits the token received in the email, and our app compares the received token with the one in the database
2. Once it checks out, we remove the activation token associated with that user + update the `activated` field to `true`

[[Web application workflow]]
